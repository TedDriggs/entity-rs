use paste::paste;

/// Generates a new ent using the provided definition to outline its name,
/// fields, and edges for use in an application.
///
/// ## Examples
///
/// ```
/// use entity::{ent, InmemoryDatabase};
///
/// ent! {
///     @name PageEnt;
///     @fields(
///         title String;
///     );
///     @edges(
///         @one header ContentEnt;
///         @maybe subheader ContentEnt;
///         @many paragraphs ContentEnt;
///     );
/// }
///
/// ent! {
///     @name ContentEnt;
///     @fields(
///         text String;
///     );
/// }
///
/// let db = InmemoryDatabase::default();
/// let page = PageEnt::new_at(
///     db,
///     String::from("some title")),
///
///
/// ```
#[macro_export]
macro_rules! ent {
    (@private @edge_type @maybe $type:ty) => {
        ::std::option::Option<$type>
    };
    (@private @edge_type @one $type:ty) => {
        $type
    };
    (@private @edge_type @many $type:ty) => {
        ::std::vec::Vec<$type>
    };

    (@private @params @fields($($name:ident $type:ty;)*);) => {
        $($name: $type,)*
    };
    (@private @params @edges($($kind:tt $name:ident $type:ty)*);) => {
        $($name: ent!(@private @edge_type $kind $type),)*
    };

    (@private @args @fields($($name:ident $_:ty;)*);) => {
        $($name,)*
    };
    (@private @args @edges($($kind:tt $name:ident $_3:ty)*);) => {
        $($name,)*
    };

    (@private @attr global_database $type:ty, $getter:expr;) => {
        impl $name<$type> {
            pub fn get(id: $crate::Id) -> $crate::DatabaseResult<Option<Self>> {
                Self::get_from($getter, id)
            }

            pub fn get_required(id: $crate::Id) -> $crate::DatabaseResult<Self> {
                Self::get_from_required($getter, id)
            }

            pub fn remove(id: $crate::Id) -> $crate::DatabaseResult<bool> {
                Self::remove_from($getter, id)
            }

            pub fn new($(@param $tail:tt)*) -> $crate::DatabaseResult<Self> {
                Self::new_at($getter, $(@arg $tail:tt)*)
            }
        }
    };

    (@name $name:ident; $(@attrs($($attr:tt)*);)? $(@fields($($field:tt)*);)? $(@edges($($edge:tt)*);)?) => {
        pub struct $name<D: $crate::Database>(D, $crate::Ent);

        ent!($(@ent $name @attr $attr_body;)* $($tail)*);

        impl<D: $crate::Database> $name<D> {
            pub fn get_from(db: D, id: $crate::Id) -> $crate::DatabaseResult<Option<Self>> {
                db.get(id)
            }

            pub fn get_from_required(db: D, id: $crate::Id) -> $crate::DatabaseResult<Self> {
                Self::get_from(db, id).and_then(|maybe_self| {
                    maybe_self.ok_or(DatabaseError::MissingEnt { id })
                })
            }

            pub fn remove_from(db: D, id: $crate::Id) -> $crate::DatabaseResult<bool> {
                db.remove(id)
            }

            paste! {
                pub fn build(db: D) -> [<$name Builder>]<D> {
                    [<$name Builder>]::from(db)
                }
            }
        }

        impl<D: $crate::Database> ::std::convert::From<$name> for D {
            fn from(x: $name) -> Self {
                self.0
            }
        }

        impl ::std::convert::From<$name> for $crate::Ent {
            fn from(x: $name) -> Self {
                self.1
            }
        }

        impl<D: $crate::Database> $crate::IEnt for $name<D> {
            fn id(&self) -> $crate::Id {
                self.1.id()
            }

            fn r#type(&self) -> &str {
                concat!(module_path!(), "::", stringify!($name))
            }

            fn created(&self) -> u64 {
                self.1.created()
            }

            fn last_updated(&self) -> u64 {
                self.1.last_updated()
            }

            fn fields(&self) -> ::std::vec::Vec<&$crate::Field> {
                self.1.fields()
            }

            fn field(&self, name: &str) -> ::std::option::Option<&$crate::Field> {
                self.1.field(name)
            }

            fn edges(&self) -> ::std::vec::Vec<&$crate::Edge> {
                self.1.edges()
            }

            fn edge(&self, name: &str) -> ::std::option::Option<&$crate::Edge> {
                self.1.edge(name)
            }
        }
    };
}

#[cfg(test)]
mod tests {
    use super::*;

    // CHIP CHIP CHIP
    //
    // The following is an example of the code that would be generated by
    // our macro so we can get a better idea of how it needs to be constructed
    // and ensure that we cover everything before writing the macro itself

    //////////////////////////////////////////////////////////////////////////
    // CONSTANTS
    //////////////////////////////////////////////////////////////////////////

    const PageEnt_TYPE: &str = concat!(module_path!(), "::", stringify!(PageEnt));

    //////////////////////////////////////////////////////////////////////////
    // ENT (CONNECTED)
    //////////////////////////////////////////////////////////////////////////

    pub struct PageEnt<D: crate::Database>(D, crate::Ent);

    impl<D: crate::Database> ::std::convert::Into<crate::Ent> for PageEnt<D> {
        fn into(self) -> crate::Ent {
            self.1
        }
    }

    /// Only created if we are given a global database for some type
    impl PageEnt<crate::InmemoryDatabase> {
        pub fn get(id: crate::Id) -> crate::DatabaseResult<::std::option::Option<Self>> {
            let global_database: crate::InmemoryDatabase = todo!();
            Self::get_from_database(global_database, id)
        }

        pub fn get_required(id: crate::Id) -> crate::DatabaseResult<Self> {
            Self::get(id).and_then(|maybe_self| match maybe_self {
                ::std::option::Option::Some(x) => ::std::result::Result::Ok(x),
                ::std::option::Option::None => {
                    ::std::result::Result::Err(crate::DatabaseError::MissingEnt { id })
                }
            })
        }

        pub fn build() -> PageEntBuilder<crate::InmemoryDatabase> {
            let global_database: crate::InmemoryDatabase = todo!();
            Self::build_with_database(global_database)
        }
    }

    impl<D: crate::Database> PageEnt<D> {
        pub fn title(&self) -> &::std::string::String {
            todo!("Need a Value -> specific type try_from conversion")
        }

        pub fn set_title<VALUE: ::std::convert::Into<::std::string::String>>(
            &mut self,
            value: VALUE,
        ) {
            self.1
                .update_field(stringify!(title), crate::Value::from(value.into()))
                .expect(format!("Corrupted ent field: {}", stringify!(title)));
        }
    }

    impl<D: crate::Database> PageEnt<D> {
        pub fn load_header(&self) -> crate::DatabaseResult<::std::option::Option<ContentEnt>> {
            use crate::IEnt;
            let edge = self
                .1
                .edge(stringify!(header))
                .expect("Missing edge: header");
            match edge.value() {
                crate::EdgeValue::MaybeOne(::std::option::Option::Some(id)) => todo!(
                    r#"""
                    Would need a guaranteed way to load and cast to ContentEnt, 
                    which means both verifying via TryFrom and wrapping in a database.

                    Several options:
                    1. We require ents to implement another trait that has these methods
                    2. We assume that there is a method defined called <TYPE>::get_from_database(db, id)
                    3. We switch EVERYTHING over to serializing directly instead of using Ent,
                       which means that we can use the Any casting

                       For #3, would need to use typetag (or maybe just erased-serde) in order
                       to be able to load back a Box<dyn IEnt> from sled.

                       Additionally, for #3, we would need IEnt to require cloning in order
                       to be able to convert Box<dyn IEnt> -> &dyn IEnt -> &T -> T

                       Sled gets this for free as deserializing to a specific type will
                       give it back to us
                    """#
                ),
                crate::EdgeValue::MaybeOne(::std::option::Option::None) => {
                    ::std::result::Result::Ok(None)
                }
                _ => unreachable!(),
            }
        }

        pub fn load_subheader(&self) -> crate::DatabaseResult<ContentEnt> {
            todo!("Need a Value -> specific type try_from conversion")
        }

        pub fn load_paragraphs(&self) -> crate::DatabaseResult<::std::vec::Vec<ContentEnt>> {
            todo!("Need a Value -> specific type try_from conversion")
        }
    }

    impl<D: crate::Database> PageEnt<D> {
        /// Refreshes ent by checking database for latest version and returning it
        pub fn refresh(&mut self) -> crate::DatabaseResult<()> {
            use crate::IEnt;
            let id = self.1.id();
            Self::get_from_database(self.0.clone(), id).and_then(|maybe_self| match maybe_self {
                ::std::option::Option::Some(x) => {
                    self.1 = x.into();
                    ::std::result::Result::Ok(())
                }
                ::std::option::Option::None => {
                    ::std::result::Result::Err(crate::DatabaseError::MissingEnt { id })
                }
            })
        }

        /// Saves the ent to the database, updating this local instance's id
        /// if the database has reported a new id
        pub fn commit(&mut self) -> crate::DatabaseResult<()> {
            match self.0.insert(self.1.clone()) {
                ::std::result::Result::Ok(id) => {
                    self.1.set_id(id);
                    Ok(())
                }
                ::std::result::Result::Err(x) => ::std::result::Result::Err(x),
            }
        }

        /// Removes self from database
        pub fn remove(self) -> crate::DatabaseResult<bool> {
            use crate::IEnt;
            self.0.remove(self.1.id())
        }

        /// Retrieves ent from database with corresponding id and makes sure
        /// that it can be represented as a typed ent
        pub fn get_from_database(
            db: D,
            id: crate::Id,
        ) -> crate::DatabaseResult<::std::option::Option<Self>> {
            use crate::IEnt;
            use ::std::convert::TryFrom;
            match db.get(id) {
                ::std::result::Result::Ok(::std::option::Option::Some(ent)) => {
                    let id = ent.id();
                    let x = DetachedPageEnt::try_from(ent).map_err(|e| {
                        crate::DatabaseError::CorruptedEnt {
                            id,
                            source: ::std::boxed::Box::from(e),
                        }
                    })?;
                    ::std::result::Result::Ok(::std::option::Option::Some(Self(db, x.into())))
                }
                ::std::result::Result::Ok(::std::option::Option::None) => {
                    ::std::result::Result::Ok(::std::option::Option::None)
                }
                ::std::result::Result::Err(x) => ::std::result::Result::Err(x),
            }
        }

        /// Produces a new ent builder for the given database
        pub fn build_with_database(db: D) -> PageEntBuilder<D> {
            PageEntBuilder::default().database(db)
        }
    }

    // TODO: Why does this require static lifetime?
    impl<D: crate::Database + 'static> crate::IEnt for PageEnt<D> {
        fn id(&self) -> crate::Id {
            self.1.id()
        }

        fn r#type(&self) -> &str {
            self.1.r#type()
        }

        fn created(&self) -> u64 {
            self.1.created()
        }

        fn last_updated(&self) -> u64 {
            self.1.last_updated()
        }

        fn fields(&self) -> ::std::vec::Vec<&crate::Field> {
            self.1.fields()
        }

        fn field(&self, name: &str) -> ::std::option::Option<&crate::Field> {
            self.1.field(name)
        }

        fn edges(&self) -> ::std::vec::Vec<&crate::Edge> {
            self.1.edges()
        }

        fn edge(&self, name: &str) -> ::std::option::Option<&crate::Edge> {
            self.1.edge(name)
        }
    }

    //////////////////////////////////////////////////////////////////////////
    // ENT (DETACHED)
    //////////////////////////////////////////////////////////////////////////

    #[derive(Debug)]
    pub enum EntToPageEntError {
        EntWrongType {
            expected: ::std::string::String,
            actual: ::std::string::String,
        },
        FieldMissing {
            name: ::std::string::String,
        },
        FieldWrongType {
            name: ::std::string::String,
            expected: crate::ValueType,
            actual: crate::ValueType,
        },
        EdgeMissing {
            name: ::std::string::String,
        },
        EdgeWrongType {
            name: ::std::string::String,
            expected: crate::EdgeValueType,
            actual: crate::EdgeValueType,
        },
    }

    impl ::std::fmt::Display for EntToPageEntError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(f, "{:?}", self)
        }
    }

    impl ::std::error::Error for EntToPageEntError {}

    pub struct DetachedPageEnt(crate::Ent);

    impl ::std::convert::Into<crate::Ent> for DetachedPageEnt {
        fn into(self) -> crate::Ent {
            self.0
        }
    }

    impl ::std::convert::TryFrom<crate::Ent> for DetachedPageEnt {
        type Error = EntToPageEntError;

        fn try_from(x: crate::Ent) -> ::std::result::Result<DetachedPageEnt, Self::Error> {
            use crate::IEnt;

            if x.r#type() != PageEnt_TYPE {
                return ::std::result::Result::Err(EntToPageEntError::EntWrongType {
                    expected: PageEnt_TYPE.to_string(),
                    actual: x.r#type().to_string(),
                });
            }

            match x.field_value(stringify!(title)) {
                ::std::option::Option::None => {
                    return ::std::result::Result::Err(EntToPageEntError::FieldMissing {
                        name: stringify!(title).to_string(),
                    });
                }
                ::std::option::Option::Some(x)
                    if x.to_type()
                        != crate::ValueType::from_type_name(stringify!(String))
                            .expect("Invalid field type") =>
                {
                    return ::std::result::Result::Err(EntToPageEntError::FieldWrongType {
                        name: stringify!(title).to_string(),
                        expected: crate::ValueType::from_type_name(stringify!(String))
                            .expect("Invalid field type"),
                        actual: x.to_type(),
                    });
                }
                _ => {}
            }

            match x.edge(stringify!(header)) {
                ::std::option::Option::None => {
                    return ::std::result::Result::Err(EntToPageEntError::EdgeMissing {
                        name: stringify!(header).to_string(),
                    });
                }
                ::std::option::Option::Some(x) if x.to_type() != crate::EdgeValueType::One => {
                    return ::std::result::Result::Err(EntToPageEntError::EdgeWrongType {
                        name: stringify!(header).to_string(),
                        expected: crate::EdgeValueType::One,
                        actual: x.to_type(),
                    });
                }
                _ => {}
            }

            match x.edge(stringify!(subheader)) {
                ::std::option::Option::None => {
                    return ::std::result::Result::Err(EntToPageEntError::EdgeMissing {
                        name: stringify!(subheader).to_string(),
                    });
                }
                ::std::option::Option::Some(x) if x.to_type() != crate::EdgeValueType::MaybeOne => {
                    return ::std::result::Result::Err(EntToPageEntError::EdgeWrongType {
                        name: stringify!(subheader).to_string(),
                        expected: crate::EdgeValueType::MaybeOne,
                        actual: x.to_type(),
                    });
                }
                _ => {}
            }

            match x.edge(stringify!(paragraphs)) {
                ::std::option::Option::None => {
                    return ::std::result::Result::Err(EntToPageEntError::EdgeMissing {
                        name: stringify!(paragraphs).to_string(),
                    });
                }
                ::std::option::Option::Some(x) if x.to_type() != crate::EdgeValueType::Many => {
                    return ::std::result::Result::Err(EntToPageEntError::EdgeWrongType {
                        name: stringify!(paragraphs).to_string(),
                        expected: crate::EdgeValueType::Many,
                        actual: x.to_type(),
                    });
                }
                _ => {}
            }

            ::std::result::Result::Ok(Self(x))
        }
    }

    impl crate::IEnt for DetachedPageEnt {
        fn id(&self) -> crate::Id {
            self.0.id()
        }

        fn r#type(&self) -> &str {
            self.0.r#type()
        }

        fn created(&self) -> u64 {
            self.0.created()
        }

        fn last_updated(&self) -> u64 {
            self.0.last_updated()
        }

        fn fields(&self) -> ::std::vec::Vec<&crate::Field> {
            self.0.fields()
        }

        fn field(&self, name: &str) -> ::std::option::Option<&crate::Field> {
            self.0.field(name)
        }

        fn edges(&self) -> ::std::vec::Vec<&crate::Edge> {
            self.0.edges()
        }

        fn edge(&self, name: &str) -> ::std::option::Option<&crate::Edge> {
            self.0.edge(name)
        }
    }

    //////////////////////////////////////////////////////////////////////////
    // BUILDER
    //////////////////////////////////////////////////////////////////////////

    #[derive(Debug)]
    pub enum PageEntBuilderError {
        Database(crate::DatabaseError),
        Initialization(::std::string::String),
    }

    impl ::std::fmt::Display for PageEntBuilderError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Database(x) => write!(f, "Database: {}", x),
                Self::Initialization(x) => write!(f, "Initialization: {}", x),
            }
        }
    }

    impl ::std::error::Error for PageEntBuilderError {}

    impl ::std::convert::From<crate::DatabaseError> for PageEntBuilderError {
        fn from(x: crate::DatabaseError) -> Self {
            Self::Database(x)
        }
    }

    impl ::std::convert::From<::std::string::String> for PageEntBuilderError {
        fn from(x: ::std::string::String) -> Self {
            Self::Initialization(x)
        }
    }

    impl<'a> ::std::convert::From<&'a str> for PageEntBuilderError {
        fn from(x: &'a str) -> Self {
            Self::Initialization(x.to_string())
        }
    }

    pub struct PageEntBuilder<D: crate::Database> {
        database: ::std::option::Option<D>,
        title: ::std::option::Option<::std::string::String>,
        header: ::std::option::Option<crate::Id>,
        subheader: ::std::option::Option<::std::option::Option<crate::Id>>,
        paragraphs: ::std::option::Option<::std::vec::Vec<crate::Id>>,
    }

    impl<D: crate::Database> ::std::default::Default for PageEntBuilder<D> {
        fn default() -> Self {
            Self {
                database: ::std::option::Option::default(),
                title: ::std::option::Option::default(),
                header: ::std::option::Option::default(),
                subheader: ::std::option::Option::default(),
                paragraphs: ::std::option::Option::default(),
            }
        }
    }

    impl<D: crate::Database> PageEntBuilder<D> {
        pub fn database<VALUE: ::std::convert::Into<D>>(mut self, value: VALUE) -> Self {
            self.database = ::std::option::Option::Some(value.into());
            self
        }

        pub fn title<VALUE: ::std::convert::Into<::std::string::String>>(
            mut self,
            value: VALUE,
        ) -> Self {
            self.title = ::std::option::Option::Some(value.into());
            self
        }

        pub fn header<VALUE: ::std::convert::Into<crate::Id>>(mut self, value: VALUE) -> Self {
            self.header = ::std::option::Option::Some(value.into());
            self
        }

        pub fn subheader<VALUE: ::std::convert::Into<::std::option::Option<crate::Id>>>(
            mut self,
            value: VALUE,
        ) -> Self {
            self.subheader = ::std::option::Option::Some(value.into());
            self
        }

        pub fn paragraphs<VALUE: ::std::convert::Into<::std::vec::Vec<crate::Id>>>(
            mut self,
            value: VALUE,
        ) -> Self {
            self.paragraphs = ::std::option::Option::Some(value.into());
            self
        }

        pub fn create(self) -> ::std::result::Result<PageEnt<D>, PageEntBuilderError> {
            let mut fields = ::std::vec::Vec::new();
            let mut edges = ::std::vec::Vec::new();

            let mut field_attrs = ::std::vec::Vec::new();
            field_attrs.push(crate::FieldAttribute::Indexed);
            fields.push(crate::Field::new_with_attributes(
                "title",
                self.title.ok_or("title must be initialized")?,
                field_attrs,
            ));

            edges.push(crate::Edge::new_with_deletion_policy(
                "header",
                self.header.ok_or("header must be initialized")?,
                crate::EdgeDeletionPolicy::ShallowDelete,
            ));

            edges.push(crate::Edge::new_with_deletion_policy(
                "subheader",
                self.subheader.ok_or("subheader must be initialized")?,
                crate::EdgeDeletionPolicy::Nothing,
            ));

            edges.push(crate::Edge::new_with_deletion_policy(
                "paragraphs",
                self.paragraphs.ok_or("paragraphs must be initialized")?,
                crate::EdgeDeletionPolicy::DeepDelete,
            ));

            ::std::result::Result::Ok(PageEnt(
                self.database.ok_or("database must be initialized")?,
                crate::Ent::from_collections(crate::EPHEMERAL_ID, PageEnt_TYPE, fields, edges),
            ))
        }
    }
}
